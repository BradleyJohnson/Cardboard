WHERE I LEFT OFF:
  Still working on rounding out the tests for Membership.
  Need to build out UI admin so that I can select people to make admin
    or remove from group, etc etc. Then I can write those tests.



------------------------------------------------------------------------
Things to do
- Clean up groups layout
- Clean decide on button colors
- Matches
- Clean up modals
- Clean up Admin layout
- Send email when meetup is scheduled
- Send reminder to bring a game if it's nominated
- Send email for confirmation about game results
- Favicon


------------------------------------------------------------------------




------------------------------------------------------------------------
Archive

  3. Admin panel for a group. I can have an AdminController, without having a model associated with it, right?
  Thinking of having a modal pop up that you can annoint new admins or remove people from the group. How else
  might I do that?

  4. How to really implement authorization. Is it possible without using CanCan or Pundit? It's easy to just
  conditionally render a button. But that's no good. Here's an idea (using the admin role and memberships controller
  as an example). How about I create an extra controller action on Memberships called #create_admin which will utilize
  a service object to update the membership. Now the Auth part. I will create a before_action: method similar to
  the authenticate_user! from Devise. So, before that controller action is accessed the user must be verified as
  an Admin of that group.

  5. Test helpers? Factory Girl? Really sick of long winded test setup.

  1. How to store a variable amount of attributes on an active record model. ie I will have a game model and sometime
  that game model will have a single game mechanic on it, such as "Hand Management". Othertimes, with complex games
  I will have multiple game mechanics like "Hand Management", "Card Drafting", and "Area Control". Whats the best way
  to simulate this in a model? Would it be best to create another model for game mechanics and simply use a join
  table?
        ##### Create a new model Mechanic. It will have one property eg "Card Drafting" or "Dice Rolling". Then
              then establish a one to many relationship with a game model. One game has many mechanics. A mechanic
              belongs to a game.

  2. Ask about whether or not it's best to scrape the API or just call it. It would be nice to simply call it but
  their data is pretty weird, comes back in XML and seems to be generally disorganized. One concern, how would I account
  for people owning copies of the same game.

  3. How to perform authorization through an ajax call. For example in those handlers for making someone an admin or
  booting them from group. Do I send the session with the request? Then handle the authorization at the controller? They
  are authorized once when they hit the admin page. Is that enough?

  4. Ask how to inherit rails helpers like redirect_to and path helpers for my service objects.



  Service Objects
    Pass in group name into the service object through group_params[:name]. Controller knows nothing about group creation.
    As in, the service object should create the Group as well. That way it is fully decoupled from the controller.
    The one other thing the controller has is the typical error handling like what's seen with scaffolds. Something like:
    founded_group = FoundGroupService.new(group_params[:name], user_id)

    if founded_group
      redirect_to whatevs
    else
      do the error thing here
    end

    Ideas for Service objects:
      1. Service for creating an admin
      2. Service for removing an admin
      3. Service for removing a member (no idea how to ban someone)
      4. Service for founding group (already started, first one I tried)




          SERVICE OBJECT TEST EXAMPLES

    expect{ Group.found(@whatevs, more whatevs) }.to change(Group, :count).by(1)
    expect{ Group.found(@whatevs, more whatevs) }.to change(Group, :count).from(0).to(1)

          SEPARATE


    before do
    @memeber = a new member
    end


    it 'creates a new group' do
    founder_service = FoundGroup.new (@member, 'group name')

    expect{ founder_service.found_group }.to change(Group, :count).from(0).to(1)
    end


    it 'returns a  new group' do
    founder_service = FoundGroup.new (@member, 'group name')
    group = found_service.found_group

    expect(group.name).to eq('group_name')
    end
