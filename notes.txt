WHERE I LEFT OFF:
  Still working on rounding out the tests for Membership.
  Still need to create service object mentioned in comments for group_spec
  Need to build out UI admin so that I can select people to make admin
    or remove from group, etc etc. Then I can write those tests.


        #### Create a new page for the admin stuff 300/group/1/admin and create an #authorize_user method on the
        application controller and also a new AdminController to handle the actions on the admin page. To lock someone
        out of the page do a before_filter on the Admin controller that calls the authorize_user method and redirect
        with a notice if the user isn't authorized.

------------------------------------------------------------------------

Service Objects
  Pass in group name into the service object through group_params[:name]. Controller knows nothing about group creation.
  As in, the service object should create the Group as well. That way it is fully decoupled from the controller.
  The one other thing the controller has is the typical error handling like what's seen with scaffolds. Something like:
  founded_group = FoundGroupService.new(group_params[:name], user_id)

  if founded_group
    redirect_to whatevs
  else
    do the error thing here
  end

  Ideas for Service objects:
    1. Service for creating an admin
    2. Service for removing an admin
    3. Service for removing a member (no idea how to ban someone)
    4. Service for founding group (already started, first one I tried)




        SERVICE OBJECT TEST EXAMPLES

  expect{ Group.found(@whatevs, more whatevs) }.to change(Group, :count).by(1)
  expect{ Group.found(@whatevs, more whatevs) }.to change(Group, :count).from(0).to(1)

        SEPARATE


  before do
  @memeber = a new member
  end


  it 'creates a new group' do
  founder_service = FoundGroup.new (@member, 'group name')

  expect{ founder_service.found_group }.to change(Group, :count).from(0).to(1)
  end


  it 'returns a  new group' do
  founder_service = FoundGroup.new (@member, 'group name')
  group = found_service.found_group

  expect(group.name).to eq('group_name')
  end

------------------------------------------------------------------------




BGG API
  http://www.boardgamegeek.com/xmlapi/boardgame/<game id>  game id example: 12333 (twilight struggle)
  http://bgg-json.azurewebsites.net/collection/<user name>  game id example: etochort (nice 3rd party json)


------------------------------------------------------------------------

Questions for John/Colt

  1. How to store a variable amount of attributes on an active record model. ie I will have a game model and sometime
  that game model will have a single game mechanic on it, such as "Hand Management". Othertimes, with complex games
  I will have multiple game mechanics like "Hand Management", "Card Drafting", and "Area Control". Whats the best way
  to simulate this in a model? Would it be best to create another model for game mechanics and simply use a join
  table?

  2. Ask about whether or not it's best to scrape the API or just call it. It would be nice to simply call it but
  their data is pretty weird, comes back in XML and seems to be generally disorganized. One concern, how would I account
  for people owning copies of the same game.

  3. Admin panel for a group. I can have an AdminController, without having a model associated with it, right?
  Thinking of having a modal pop up that you can annoint new admins or remove people from the group. How else
  might I do that?

  4. How to really implement authorization. Is it possible without using CanCan or Pundit? It's easy to just
  conditionally render a button. But that's no good. Here's an idea (using the admin role and memberships controller
  as an example). How about I create an extra controller action on Memberships called #create_admin which will utilize
  a service object to update the membership. Now the Auth part. I will create a before_action: method similar to
  the authenticate_user! from Devise. So, before that controller action is accessed the user must be verified as
  an Admin of that group.
